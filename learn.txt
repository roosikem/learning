import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.security.SecureRandom;
import java.util.Random;

@Service
public class PasswordGeneratorService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    // Characters allowed in the password
    private static final String CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%";

    // Length of the generated password
    private static final int PASSWORD_LENGTH = 12;

    // Secure random instance for generating passwords
    private static final Random random = new SecureRandom();

    // Method to generate a random password
    public String generateRandomPassword() {
        StringBuilder password = new StringBuilder(PASSWORD_LENGTH);
        for (int i = 0; i < PASSWORD_LENGTH; i++) {
            password.append(CHARACTERS.charAt(random.nextInt(CHARACTERS.length())));
        }
        return password.toString();
    }

    // Method to generate a random password and encode it using PasswordEncoder
    public String generateEncodedPassword() {
        String rawPassword = generateRandomPassword();
        String encodedPassword = passwordEncoder.encode(rawPassword);
        System.out.println("Generated Password: " + rawPassword);
        System.out.println("Encoded Password: " + encodedPassword);
        return encodedPassword;
    }
}


// Example list of URLs
const urls = [
  "https://example.com/file1.jpg",
  "https://example.com/file2.png",
  "https://example.com/file3.pdf",
  "https://example.com/file4.gif",
  "https://example.com/file5.mp3",
  "https://example.com/file6.mp4",
  "https://example.com/file7.wav",
  "https://example.com/file8.zip"
];

// Mapping extensions to content types
const mimeTypes = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.bmp': 'image/bmp',
  '.webp': 'image/webp',
  '.mp3': 'audio/mpeg',
  '.wav': 'audio/wav',
  '.ogg': 'audio/ogg',
  '.flac': 'audio/flac',
  '.aac': 'audio/aac',
  '.mp4': 'video/mp4',
  '.avi': 'video/x-msvideo',
  '.mov': 'video/quicktime',
  '.mkv': 'video/x-matroska',
  '.flv': 'video/x-flv',
  '.pdf': 'application/pdf',
  '.doc': 'application/msword',
  '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  '.xls': 'application/vnd.ms-excel',
  '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  '.zip': 'application/zip',
  '.rar': 'application/x-rar-compressed',
  '.tar.gz': 'application/gzip'
};

// Function to find the MIME type based on the URL's extension
function getContentType(url) {
  const lowerCaseUrl = url.toLowerCase();
  // Find the corresponding MIME type
  for (let extension in mimeTypes) {
    if (lowerCaseUrl.endsWith(extension)) {
      return mimeTypes[extension];
    }
  }
  return 'unknown'; // Return unknown if the extension is not found
}

// Function to return URLs with their content types
function getUrlsWithContentTypes(urls) {
  return urls.map(url => {
    return {
      url: url,
      contentType: getContentType(url)
    };
  });
}

function getFileName(url) {
    return url.substring(url.lastIndexOf('/') + 1);
}

// Function to extract the original file name from a URL
function getOriginalFileName(url) {
    if (url == null || typeof url !== 'string') {
        return 'invalid';  // Handle invalid URLs
    }
    const lastSlashIdx = url.lastIndexOf('/');
    if (lastSlashIdx === -1) {
        return 'invalid';  // Invalid URL structure
    }
    
    return url.substring(lastSlashIdx + 1);  // Extract the original file name
}

// Function to generate a new file name with UUID while keeping the extension
function alterFileName(originalFileName) {
    const dotIdx = originalFileName.lastIndexOf('.');  // Find the position of the last dot
    if (dotIdx === -1) {
        return 'invalid';  // If no extension is found
    }

    const nameWithoutExtension = originalFileName.substring(0, dotIdx);  // File name without extension
    const extension = originalFileName.substring(dotIdx);  // File extension (e.g., .jpg, .png)
    
    // Generate a new file name with UUID
    const newFileName = `${nameWithoutExtension}_${uuidv4()}${extension}`;
    
    return newFileName;
}



// Call the function
const result = getUrlsWithContentTypes(urls);

// Display the result
console.log(result);

@Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // Forward requests starting with /cms to the static index.html
        registry.addViewController("/cms/{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/index.html");
        registry.addViewController("/cms/**/{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/index.html");
        registry.addViewController("/cms/{spring:[a-zA-Z0-9\\-_]+}/**{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/index.html");
registry.addViewController("/cms/{path:^(?!static|api).*$}/**")
                .setViewName("forward:/static/index.html");

registry.addViewController("/cms/{path:^(?!static|api|static/.*\\.css|static/.*\\.js|static/.*\\.png|static/.*\\.jpg|static/.*\\.jpeg|static/.*\\.gif|static/.*\\.svg|static/.*\\.woff|static/.*\\.woff2|static/.*\\.ttf|static/.*\\.eot).*$}/**")
                .setViewName("forward:/static/index.html");
    }

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // Map static resources under the /cms path
        registry.addResourceHandler("/cms/static/**")
                .addResourceLocations("classpath:/static/");

// Additionally handle any specific MIME types if needed
        registry.addResourceHandler("/cms/static/css/**").addResourceLocations("classpath:/static/css/");
        registry.addResourceHandler("/cms/static/js/**").addResourceLocations("classpath:/static/js/");
        registry.addResourceHandler("/cms/static/images/**").addResourceLocations("classpath:/static/images/");
    }


 registry.addViewController("/cms/{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/cms/index.html");
        registry.addViewController("/cms/**/{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/cms/index.html");
        registry.addViewController("/cms/{spring:[a-zA-Z0-9\\-_]+}/**{spring:[a-zA-Z0-9\\-_]+}")
                .setViewName("forward:/static/cms/index.html");


registry.addViewController("/cms/{path:^(?!static|_next|.*\\..*$).*$}/**")
                .setViewName("forward:/index.html");


@Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // Serve static resources correctly from the public folder
        registry.addResourceHandler("/**")
                .addResourceLocations("classpath:/public/");
    }


Title: Proxy Error Causing Intermittent Failures in Auth and Message APIs

Description:

We have observed a Proxy Error impacting both the auth API and the message API. The issue is not isolated to the auth API; it affects both APIs due to network disturbances.

Detailed Analysis:
Auth API:
The auth API is failing on the first hit due to the absence of a configured retry count. Since no retry mechanism is in place, the authentication process stops immediately upon encountering the error.
Message API:
The message API also experiences the same proxy-related error. However, it has a retry count configured. The retry mechanism triggers upon failure, leading to a successful response on subsequent attempts.
Root Cause:
The underlying cause appears to be related to network or proxy issues. The proxy error is affecting multiple APIs, not just the auth API. Other APIs are also experiencing impacts due to network disruptions at the same time.
Recommendations:
Configure Retry Mechanism:
Implement a retry mechanism for the auth API, similar to the one used for the message API. This will ensure that the auth API can connect successfully on subsequent attempts if the initial request fails due to a proxy error.
Investigate Network Stability:
Conduct a thorough investigation to identify the root cause of the network disturbances. Understanding and resolving these network issues will be crucial in preventing similar proxy errors across all APIs.



Hi,

Could we schedule a call to discuss an issue I’m facing with entity mapping, specifically with or without using @DBRef?

When I update a child entity individually, the changes are not reflected everywhere, and the system is still returning the old value. I believe it would be helpful to review this together.

Please let me know a convenient time for you.

Thank you!

Hi,

Could we schedule a call to discuss an issue I’m facing with entity mapping, particularly with or without using @DBRef?

The problem occurs when we update an entity individually. If that entity is also part of another entity, the updated details do not reflect when we fetch the other entity. Instead, we still see the old details of the updated entity. I think it would be useful to review this together.

Please let me know a convenient time for you.

Thank you!

Hi,

function hasImageExtension(fileName) {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];
    const lowerCaseFileName = fileName.toLowerCase();
    return imageExtensions.some(extension => lowerCaseFileName.endsWith(extension));
}


